// ---------- FIREBASE INIT ----------
const firebaseConfig = {
  apiKey: "AIzaSyDwyviB0cz-dudEuihPWze9cAkLa58WeZs",
  authDomain: "web3memefun.firebaseapp.com",
  projectId: "web3memefun",
  storageBucket: "web3memefun.firebasestorage.app",
  messagingSenderId: "227343388230",
  appId: "1:227343388230:web:617c118813d1136958c447"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ---------- USER INIT (TELEGRAM OR BROWSER) ----------
let tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
let USER_ID;

if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) {
  USER_ID = "tg_" + tg.initDataUnsafe.user.id;
  tg.expand();
} else {
  USER_ID = localStorage.getItem("w3_user");
  if (!USER_ID) {
    USER_ID = "guest_" + Math.floor(Math.random() * 1e9);
    localStorage.setItem("w3_user", USER_ID);
  }
}

document.getElementById("userId").innerText = "User: " + USER_ID;

let USER_BAL = 0;
let PORTFOLIO = {};
let CURRENT_TOKEN = null;

// ---------- SAFE HELPERS ----------
function toNum(v, def = 0) {
  const n = Number(v);
  return isFinite(n) ? n : def;
}

function clampNumber(x, min, max) {
  x = toNum(x, min);
  if (x < min) return min;
  if (x > max) return max;
  return x;
}

function normalizeToken(t) {
  t.supply = toNum(t.supply, 1_000_000_000);
  if (t.supply <= 0) t.supply = 1_000_000_000;

  t.liquidity = toNum(t.liquidity, 0);
  if (t.liquidity < 0) t.liquidity = 0;

  t.price = t.liquidity / t.supply;
  if (!isFinite(t.price) || t.price <= 0) t.price = 0.000000000001;

  t.mc = t.liquidity;
  if (!isFinite(t.mc) || t.mc < 0) t.mc = 0;

  t.buys = toNum(t.buys, 0);
  t.sells = toNum(t.sells, 0);
  t.volume = toNum(t.volume, 0);

  return t;
}

function getStage(t) {
  if (t.mc < 5000) return "NEW";
  if (t.mc < 20000) return "MID";
  return "GRAD";
}

function getStageText(t) {
  const s = getStage(t);
  if (s === "NEW") return "New launch";
  if (s === "MID") return "Heating up";
  return "Graduated";
}

// ---------- INIT USER DOC ----------
async function initUser() {
  const ref = db.collection("users").doc(USER_ID);
  const snap = await ref.get();

  if (!snap.exists) {
    await ref.set({
      balance: 10000,
      portfolio: {},
      lastDaily: 0
    });
  }

  await loadUser();
  await ensureDemoTokens();
  await loadMarket();
}
initUser();

// ---------- LOAD USER ----------
async function loadUser() {
  const ref = db.collection("users").doc(USER_ID);
  const snap = await ref.get();
  const data = snap.data() || {};

  USER_BAL = toNum(data.balance, 0);
  PORTFOLIO = data.portfolio || {};

  document.getElementById("userBalance").innerText =
    "Balance: " + USER_BAL.toLocaleString() + " USDT";

  loadPortfolio();
}

// ---------- TABS ----------
function openTab(id) {
  document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
  document.getElementById(id).classList.add("active");
}

// ---------- DEMO TOKENS ----------
async function ensureDemoTokens() {
  const snap = await db.collection("tokens").limit(1).get();
  if (!snap.empty) return;

  const demo = [
    {
      name: "DOGEJESUS",
      ticker: "DJS",
      img: "https://i.imgur.com/0Z8FQJm.png",
      mc: 6000
    },
    {
      name: "CATGOD",
      ticker: "CAT",
      img: "https://i.imgur.com/Xg5Ww1S.png",
      mc: 12000
    },
    {
      name: "MALIOTCOIN",
      ticker: "MAL",
      img: "https://i.imgur.com/eZz5f8M.png",
      mc: 25000
    }
  ];

  for (let d of demo) {
    let supply = 1_000_000_000;
    let liquidity = d.mc;
    let price = liquidity / supply;
    let id = "demo_" + d.ticker;

    await db.collection("tokens").doc(id).set({
      id,
      name: d.name,
      ticker: d.ticker,
      img: d.img,
      supply,
      liquidity,
      price,
      mc: liquidity,
      created: Date.now(),
      buys: 0,
      sells: 0,
      volume: 0
    });
  }
}

// ---------- CREATE TOKEN ----------
async function createToken() {
  const name = document.getElementById("tokenName").value.trim();
  const ticker = document.getElementById("tokenTicker").value.trim().toUpperCase();
  const img = document.getElementById("tokenImg").value.trim();
  const pre = toNum(document.getElementById("preBuy").value, 0);

  if (!name || !ticker || !img) {
    alert("Fill all fields.");
    return;
  }

  if (USER_BAL < 2000) {
    alert("You need at least 2000 USDT to launch.");
    return;
  }

  USER_BAL -= 2000;
  USER_BAL = clampNumber(USER_BAL, 0, 10_000_000_000);
  await db.collection("users").doc(USER_ID).update({ balance: USER_BAL });

  const supply = 1_000_000_000;
  let liquidity = 4000 + pre;
  let price = liquidity / supply;
  const id = Date.now().toString();

  let token = {
    id,
    name,
    ticker,
    img,
    supply,
    liquidity,
    price,
    mc: liquidity,
    created: Date.now(),
    buys: 0,
    sells: 0,
    volume: pre || 0
  };
  token = normalizeToken(token);

  await db.collection("tokens").doc(id).set(token);

  if (pre > 0) {
    const tokens = pre / token.price;

    if (!PORTFOLIO[id]) {
      PORTFOLIO[id] = { amount: 0, invest: 0 };
    }
    PORTFOLIO[id].amount += tokens;
    PORTFOLIO[id].invest += pre;

    await db.collection("users").doc(USER_ID).update({
      portfolio: PORTFOLIO
    });
  }

  alert("ðŸš€ Token launched!");
  await loadUser();
  await loadMarket();
}

// ---------- LOAD MARKET ----------
async function loadMarket() {
  const snap = await db.collection("tokens").orderBy("mc", "desc").get();

  const newBox = document.getElementById("marketNew");
  const midBox = document.getElementById("marketMid");
  const gradBox = document.getElementById("marketGrad");

  newBox.innerHTML = "";
  midBox.innerHTML = "";
  gradBox.innerHTML = "";

  snap.forEach(doc => {
    let t = normalizeToken(doc.data());

    const stage = getStage(t);
    const mcText = Math.floor(t.mc).toLocaleString();
    const priceText = t.price.toFixed(12);
    const width = clampNumber(t.mc / 400, 5, 100);

    const cardHtml = `
      <div class="card" onclick="openTrade('${t.id}')">
        <div class="market-row">
          <img src="${t.img}" width="40" height="40" />
          <div class="market-info">
            <b>${t.name} (${t.ticker})</b><br/>
            <span class="price-text">
              Price: ${priceText} USDT<br/>
              MC: ${mcText} USDT<br/>
              Vol: ${Math.floor(t.volume || 0).toLocaleString()} â€¢ Buys: ${t.buys} â€¢ Sells: ${t.sells}
            </span><br/>
            <span class="stage-pill ${
              stage === "NEW" ? "stage-new" :
              stage === "MID" ? "stage-mid" : "stage-grad"
            }">${getStageText(t)}</span>
          </div>
        </div>
      </div>
    `;

    if (stage === "NEW") newBox.innerHTML += cardHtml;
    else if (stage === "MID") midBox.innerHTML += cardHtml;
    else gradBox.innerHTML += cardHtml;
  });
}

// ---------- PORTFOLIO ----------
async function loadPortfolio() {
  const box = document.getElementById("portfolioList");
  box.innerHTML = "";

  let totalValue = 0;
  const ids = Object.keys(PORTFOLIO);

  if (ids.length === 0) {
    box.innerHTML = "<p>No tokens yet.</p>";
    return;
  }

  for (let tid of ids) {
    const snap = await db.collection("tokens").doc(tid).get();
    if (!snap.exists) continue;
    let t = normalizeToken(snap.data());

    const hold = toNum(PORTFOLIO[tid].amount, 0);
    const value = hold * t.price;
    totalValue += isFinite(value) ? value : 0;

    box.innerHTML += `
      <div class="card">
        <b>${t.name} (${t.ticker})</b><br/>
        Amount: ${hold.toFixed(2)}<br/>
        Value: ${value.toFixed(2)} USDT<br/>
        <button onclick="openTrade('${t.id}')">View / Trade</button>
      </div>
    `;
  }

  box.innerHTML += `
    <div class="card">
      <b>Total portfolio value:</b> ${totalValue.toFixed(2)} USDT
    </div>
  `;
}

// ---------- DAILY BONUS ----------
async function claimDaily() {
  const ref = db.collection("users").doc(USER_ID);
  const snap = await ref.get();
  const data = snap.data() || {};

  const now = Date.now();
  if (data.lastDaily && now - data.lastDaily < 24 * 60 * 60 * 1000) {
    alert("Already claimed. Come back later.");
    return;
  }

  USER_BAL += 500;
  USER_BAL = clampNumber(USER_BAL, 0, 10_000_000_000);

  await ref.update({
    balance: USER_BAL,
    lastDaily: now
  });

  await loadUser();
  alert("Claimed 500 USDT!");
}

// ---------- TRADE PANEL / DETAILS ----------
async function openTrade(id) {
  const snap = await db.collection("tokens").doc(id).get();
  if (!snap.exists) return alert("Token not found");
  let t = normalizeToken(snap.data());
  CURRENT_TOKEN = t;

  document.getElementById("tradeImg").src = t.img;
  document.getElementById("tradeTitle").innerText =
    `${t.name} (${t.ticker})`;
  document.getElementById("tradeStage").innerText =
    `${getStageText(t)} â€¢ MC: ${Math.floor(t.mc).toLocaleString()} USDT`;

  const statsDiv = document.getElementById("tradeStats");
  const userHold = toNum(PORTFOLIO[t.id]?.amount, 0);
  const userVal = userHold * t.price;

  statsDiv.innerHTML = `
    <div>Price: <b>${t.price.toFixed(12)} USDT</b></div>
    <div>Buys: ${t.buys} â€¢ Sells: ${t.sells}</div>
    <div>Volume: ${Math.floor(t.volume || 0).toLocaleString()} USDT</div>
    <div>Your bag: ${userHold.toFixed(2)} (${userVal.toFixed(2)} USDT)</div>
  `;

  renderChart(t);

  document.getElementById("buyAmount").value = "";
  document.getElementById("sellPercent").value = "";

  document.getElementById("tradePanel").classList.remove("hidden");
}

function closeTrade() {
  document.getElementById("tradePanel").classList.add("hidden");
  CURRENT_TOKEN = null;
}

// fake tiny chart based on price
function renderChart(t) {
  const box = document.getElementById("priceChart");
  const base = t.price;
  let bars = [];
  for (let i = 0; i < 7; i++) {
    const mult = 0.85 + Math.random() * 0.3; // 0.85â€“1.15
    bars.push(base * mult);
  }
  const max = Math.max(...bars);
  box.innerHTML = `<div class="chart-row">${
    bars.map((v, i) => {
      const h = Math.max(8, (v / max) * 40);
      const down = i > 0 && v < bars[i - 1];
      return `<div class="chart-bar ${down ? "down" : ""}" style="height:${h}px"></div>`;
    }).join("")
  }</div>`;
}

// ---------- BUY ----------
async function buyToken() {
  if (!CURRENT_TOKEN) return;
  const amt = toNum(document.getElementById("buyAmount").value, 0);
  if (!amt || amt <= 0) return alert("Invalid amount");
  if (amt > USER_BAL) return alert("Not enough balance");

  const tokenRef = db.collection("tokens").doc(CURRENT_TOKEN.id);
  const snap = await tokenRef.get();
  let t = normalizeToken(snap.data());

  const fee = amt * 0.01;
  const net = amt - fee;

  const tokens = net / t.price;

  USER_BAL -= amt;
  USER_BAL = clampNumber(USER_BAL, 0, 10_000_000_000);
  await db.collection("users").doc(USER_ID).update({ balance: USER_BAL });

  if (!PORTFOLIO[t.id]) {
    PORTFOLIO[t.id] = { amount: 0, invest: 0 };
  }
  PORTFOLIO[t.id].amount = toNum(PORTFOLIO[t.id].amount, 0) + tokens;
  PORTFOLIO[t.id].invest = toNum(PORTFOLIO[t.id].invest, 0) + amt;

  await db.collection("users").doc(USER_ID).update({ portfolio: PORTFOLIO });

  t.liquidity += net;
  t.volume += amt;
  t = normalizeToken(t);
  t.buys++;

  await tokenRef.update(t);

  await loadUser();
  await loadMarket();
  alert("Buy success!");
  closeTrade();
}

// ---------- SELL ----------
async function sellToken() {
  if (!CURRENT_TOKEN) return;
  const percent = toNum(document.getElementById("sellPercent").value, 0);
  if (!percent || percent <= 0 || percent > 100) {
    return alert("Enter % between 1 and 100");
  }

  const tokenRef = db.collection("tokens").doc(CURRENT_TOKEN.id);
  const snap = await tokenRef.get();
  let t = normalizeToken(snap.data());

  if (!PORTFOLIO[t.id] || toNum(PORTFOLIO[t.id].amount, 0) <= 0) {
    return alert("You have no tokens.");
  }

  const hold = toNum(PORTFOLIO[t.id].amount, 0);
  const sellAmount = hold * (percent / 100);
  const value = sellAmount * t.price;

  const fee = value * 0.01;
  const net = value - fee;

  PORTFOLIO[t.id].amount = hold - sellAmount;
  if (PORTFOLIO[t.id].amount <= 0.0000001) {
    delete PORTFOLIO[t.id];
  }

  await db.collection("users").doc(USER_ID).update({ portfolio: PORTFOLIO });

  USER_BAL += net;
  USER_BAL = clampNumber(USER_BAL, 0, 10_000_000_000);
  await db.collection("users").doc(USER_ID).update({ balance: USER_BAL });

  t.liquidity -= net;
  if (t.liquidity < 0) t.liquidity = 0;
  t.volume += value;
  t = normalizeToken(t);
  t.sells++;

  await tokenRef.update(t);

  await loadUser();
  await loadMarket();
  alert("Sell success!");
  closeTrade();
}

// ---------- SIMPLE BOT (PUMP / DUMP RANDOMLY) ----------
function rand(min, max) {
  return Math.random() * (max - min) + min;
}

async function runBots() {
  const snap = await db.collection("tokens").get();

  snap.forEach(async doc => {
    let t = normalizeToken(doc.data());

    if (t.mc < 2000) return;

    // random small pump
    if (Math.random() < 0.30) {
      let amount = rand(10, Math.max(20, t.mc * 0.01));
      t.liquidity += amount;
      t.volume += amount;
      t = normalizeToken(t);
      t.buys++;
      await db.collection("tokens").doc(t.id).update(t);
    }

    // random small dump
    if (Math.random() < 0.18) {
      let amount = rand(10, Math.max(25, t.mc * 0.008));
      t.liquidity -= amount;
      if (t.liquidity < 0) t.liquidity = 0;
      t.volume += amount;
      t = normalizeToken(t);
      t.sells++;
      await db.collection("tokens").doc(t.id).update(t);
    }
  });

  loadMarket();
  loadPortfolio();

  const wait = rand(15000, 25000); // 15â€“25 seconds
  setTimeout(runBots, wait);
}

setTimeout(runBots, 5000);
  
